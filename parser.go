package vected

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"strings"
	"text/template"

	"golang.org/x/net/html"
	"golang.org/x/net/html/atom"
)

// ToNode recursively transform n to a *Node.
func ToNode(n *html.Node) *Node {
	node := &Node{
		Type:      NodeType(uint32(n.Type)),
		Data:      n.Data,
		Namespace: n.Namespace,
		Attr:      make([]Attribute, len(n.Attr)),
	}
	for _, v := range node.Attr {
		node.Attr = append(node.Attr, Attribute{
			Namespace: v.Namespace,
			Key:       v.Key,
			Val:       v.Val,
		})
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.TextNode && strings.TrimSpace(c.Data) == "" {
			continue
		}
		node.Children = append(node.Children, ToNode(c))
	}
	return node
}

// Clear removes nodes injected by the parser.
func Clear(n *Node) *Node {
	if len(n.Children) > 0 &&
		atom.Lookup([]byte(n.Children[0].Data)) == atom.Html {
		// this is the root node. The html parser injects html,bead,body tags by
		// default.
		//
		// The plan here is to remove the injected  tags
		body := n.Children[0].Children[1]
		if len(body.Children) > 1 {
			// wrap the children in a container
			return &Node{
				Type:     ElementNode,
				Data:     ContainerNode,
				Children: body.Children,
			}
		}
		return body.Children[0]
	}
	return n
}

const fnTpl = `// Code generated by vected DO NOT EDIT.
package {{.pkg}}

import (
	"context"
	{{if .hasFmt -}}
	"fmt"
	{{end}}
	
	"github.com/gernest/vected"
)

var H =vected.NewNode
var HA= vected.Attr
var HAT= vected.Attrs

{{range .ctx}}
// Render implements vected.Renderer interface.
func ({{.Recv}} {{.StructName}})Render(ctx context.Context, props vected.Props, state vected.State)*vected.Node{
	return {{text .Node -}}
}
{{end}}

`

type Context struct {
	Recv       string
	StructName string
	Node       *Node
}

// GenerateRenderMethod using the given context, this returns a new go file with
// the Render method attached to the struct defined in ctx.
func GenerateRenderMethod(pkg string, ctx ...Context) ([]byte, error) {
	tpl, err := template.New("n").Funcs(template.FuncMap{
		"text": func(n *Node) string {
			return printNode(n, 0)
		},
	}).Parse(fnTpl)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	buf.Reset()
	var hasFmt bool
	for k := range ctx {
		if strings.Contains(printNode(ctx[k].Node, 0), "fmt.Sprintf") {
			hasFmt = true
			break
		}
	}
	err = tpl.Execute(&buf, map[string]interface{}{
		"pkg":    pkg,
		"ctx":    ctx,
		"hasFmt": hasFmt,
	})
	if err != nil {
		return nil, err
	}
	// ioutil.WriteFile("test/test.gen.go", buf.Bytes(), 0600)
	return format.Source(buf.Bytes())
}

// Parse parses src
func Parse(r io.Reader) ([]*Node, error) {
	base := root()
	n, err := html.ParseFragment(r, base)
	if err != nil {
		return nil, err
	}
	var rst []*Node
	for _, v := range n {
		rst = append(rst, ToNode(v))
	}
	return rst, nil
}

func root() *html.Node {
	return &html.Node{
		DataAtom: atom.Div,
		Type:     html.ElementNode,
		Data:     "div",
	}
}

// ParseString helper that wraps s to io.Reader.
func ParseString(s string) ([]*Node, error) {
	return Parse(strings.NewReader(s))
}

func parseExpression(x string) (ast.Expr, error) {
	return parser.ParseExpr(x)
}

func printAttr(a Attribute) string {
	return fmt.Sprintf("HA(%q,%q,%v)", a.Namespace, a.Key, interpret(a.Val))
}

func interpretText(v string) string {
	x := strings.Index(v, "{")
	if x != -1 {
		p := strings.Split(v, "{")
		s := ""
		var args []string
		for _, i := range p {
			s += "%v"
			ei := strings.Index(i, "}")
			if ei != -1 {
				if ei < len(i)-1 {
					args = append(args, i[:ei])
					s += "%s"
					args = append(args, fmt.Sprintf("%q", i[ei+1:]))
					continue
				}
				i = i[:ei]
			} else {
				i = fmt.Sprintf("%q", i)
			}
			args = append(args, i)
		}
		return fmt.Sprintf("fmt.Sprintf(%q,%s)", s, strings.Join(args, ","))
	}
	return v
}
func printNode(n *Node, level int) string {
	var v string
	if n.Type == TextNode {
		x := interpretText(n.Data)
		v = indent((fmt.Sprintf("H(%d,%q,%s",
			n.Type, n.Namespace, x)), level)
	} else {
		v = indent((fmt.Sprintf("H(%d,%q,%q",
			n.Type, n.Namespace, n.Data)), level)
	}
	if len(n.Attr) > 0 {
		v += indent(",HAT(", level+2)
		for _, attr := range n.Attr {
			if attr.Key == "" {
				continue
			}
			v += "\n"
			v += indent(printAttr(attr), level+4)
			v += ","
		}
		v += indent(")", level+2)
	} else {
		v += ",nil"
	}
	if len(n.Children) > 0 {
		v += ","
		for _, ch := range n.Children {
			switch ch.Type {
			case TextNode:
				x := strings.TrimSpace(ch.Data)
				if x == "" {
					continue
				}
			case CommentNode:
				continue
			}
			v += "\n"
			v += printNode(ch, level+4)
			v += ","
		}

	}
	v += indent(")", level)
	return v
}

func interpret(v interface{}) string {
	switch e := v.(type) {
	case nil:
		return "nil"
	case string:
		e = strings.TrimSpace(e)
		if strings.HasPrefix(e, "{") {
			// We remove prefix { and suffix }, pick what is left and evaluate if it is a
			// valid go expression.
			//
			// TODO handle errors when given wrong expressions.
			x := strings.TrimPrefix(e, "{")
			x = strings.TrimSuffix(x, "}")
			x = strings.TrimSpace(x)
			v, err := parser.ParseExpr(x)
			if err != nil {
				return "nil"
			}
			var buf bytes.Buffer
			fset := token.NewFileSet()
			printer.Fprint(&buf, fset, v)
			return buf.String()
		}
		return fmt.Sprintf("%q", e)
	default:
		return "nil"
	}
}

func indent(v string, n int) string {
	s := " "
	for i := 0; i < n; i++ {
		s += " "
	}
	return s + v
}
