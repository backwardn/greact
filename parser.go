package vected

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"strings"

	"github.com/gernest/vected/expr"
	"golang.org/x/net/html"
	"golang.org/x/net/html/atom"
)

// ToNode recursively transform n to a *Node.
func ToNode(n *html.Node) *Node {
	node := &Node{
		Type:      NodeType(uint32(n.Type)),
		Data:      n.Data,
		Namespace: n.Namespace,
	}
	for _, v := range n.Attr {
		if v.Key == "" {
			continue
		}
		node.Attr = append(node.Attr, Attribute{
			Namespace: v.Namespace,
			Key:       v.Key,
			Val:       v.Val,
		})
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.TextNode && strings.TrimSpace(c.Data) == "" {
			continue
		}
		node.Children = append(node.Children, ToNode(c))
	}
	return node
}

const fnTpl = `// Code generated by vected DO NOT EDIT.
package {{.pkg}}

import (
	"context"
	{{if .hasFmt -}}
	"fmt"
	{{end}}
	
	"github.com/gernest/vected"
)

var H =vected.NewNode
var HA= vected.Attr
var HAT= vected.Attrs

{{range .ctx}}
// Render implements vected.Renderer interface.
func ({{.Recv}} {{.StructName}})Render(ctx context.Context, props vected.Props, state vected.State)*vected.Node{
	return {{text .Node -}}
}
{{end}}

`

// Parse parses src
func Parse(r io.Reader) (*Node, error) {
	base := root()
	n, err := html.ParseFragment(r, base)
	if err != nil {
		return nil, err
	}
	var rst []*Node
	for _, v := range n {
		node := ToNode(v)
		if node.Type == TextNode && strings.TrimSpace(node.Data) == "" {
			continue
		}
		rst = append(rst, node)
	}
	container := &Node{
		Type: ElementNode,
		Data: "div",
	}
	switch len(rst) {
	case 0:
		return container, nil
	case 1:
		return rst[0], nil
	default:
		container.Children = rst
		return container, nil
	}
}

func root() *html.Node {
	return &html.Node{
		DataAtom: atom.Div,
		Type:     html.ElementNode,
		Data:     "div",
	}
}

// ParseString helper that wraps s to io.Reader.
func ParseString(s string) (*Node, error) {
	return Parse(strings.NewReader(s))
}

// process templates in text nodes
func interpretText(v string) (string, error) {
	parts, err := expr.ExtractExpressions(v, '{', '}')
	if err != nil {
		return "", err
	}

	// for text all plain nodes are strings
	var args []ast.Expr
	for _, v := range parts {
		if v.Plain {
			a, err := v.QuoteExpr()
			if err != nil {
				return "", err
			}
			args = append(args, a)
		} else {
			a, err := v.Expr()
			if err != nil {
				return "", err
			}
			args = append(args, a)
		}
	}
	e := expr.Wrap(args...)
	var buf bytes.Buffer
	printer.Fprint(&buf, token.NewFileSet(), e)
	return buf.String(), nil
}

// interpret   attributes templates.
func interpret(v interface{}) (string, error) {
	switch e := v.(type) {
	case nil:
		return "nil", nil
	case string:
		e = strings.TrimSpace(e)
		if strings.HasPrefix(e, "{") {
			parts, err := expr.ExtractExpressions(e, '{', '}')
			if err != nil {
				return "", err
			}
			var args []ast.Expr
			for _, v := range parts {
				if v.Plain && strings.Contains(v.Text, "\"") {
					a, err := v.QuoteExpr()
					if err != nil {
						return "", err
					}
					args = append(args, a)
				} else {
					a, err := v.Expr()
					if err != nil {
						return "", err
					}
					args = append(args, a)
				}
			}
			var e ast.Expr
			if len(args) == 1 {
				e = args[0]
			} else {
				e = expr.Wrap(args...)
			}
			var buf bytes.Buffer
			printer.Fprint(&buf, token.NewFileSet(), e)
			return buf.String(), nil
		}
		return fmt.Sprintf("%q", e), nil
	default:
		return "nil", nil
	}
}
