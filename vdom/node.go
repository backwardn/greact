package vdom

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"io"
	"strings"
	"text/template"

	"golang.org/x/net/html"
	"golang.org/x/net/html/atom"
)

const (
	// ContainerNode this is tha name of a node which acts as a container to a
	// slice of other nodes.
	ContainerNode = "__internal_container___"
)

// Attribute represent html attribute. Val can be any valid go expression.
type Attribute struct {
	Namespace, Key string
	Val            interface{}
}

func (a Attribute) Print() string {
	if a.Namespace != "" {
		return fmt.Sprintf("{Namespace:%q,Key:%q,Val:%v},\n",
			a.Namespace, a.Key, interpret(a.Val))
	}
	return fmt.Sprintf("{Key:%q,Val:%v},\n", a.Key, interpret(a.Val))
}

type Node struct {
	Type      html.NodeType
	DataAtom  atom.Atom
	Data      string
	Namespace string
	Attr      []Attribute
	Children  []*Node
}

func (n *Node) Print(level int, child bool) string {
	v := indent("&vdom.Node{\n", level)
	if n.Type != 0 {
		v += indent("Type: html."+formatNodeType(n.Type)+",\n", level+2)
	}
	if n.DataAtom != 0 {
		v += indent("DataAtom: atom."+strings.Title(n.DataAtom.String())+",\n", level+2)
	}
	if n.Data != "" {
		v += indent("Data:"+fmt.Sprintf("%q", n.Data)+",\n", level+2)
	}
	if n.Namespace != "" {
		v += indent("Namespace:"+fmt.Sprintf("%q", n.Namespace)+",\n", level+2)
	}
	if len(n.Attr) > 0 {
		v += indent("Attr:[]vdom.Attribute{\n", level+2)
		for _, attr := range n.Attr {
			if attr.Key != "" {
				v += indent(attr.Print(), level+4)
			}
		}
		v += indent("},\n", level+2)
	}
	if len(n.Children) > 0 {
		v += indent("Children:[]*vdom.Node{\n", level+2)
		for _, ch := range n.Children {
			v += ch.Print(level+4, true)
		}
		v += indent("},\n", level+2)
	}
	if child {
		v += indent("},\n", level)
	} else {
		v += indent("}\n", level)
	}
	return v
}

func interpret(v interface{}) string {
	switch e := v.(type) {
	case nil:
		return "nil"
	case string:
		e = strings.TrimSpace(e)
		if strings.HasPrefix(e, "{") {
			x := strings.TrimPrefix(e, "{")
			x = strings.TrimSuffix(x, "}")
			x = strings.TrimSpace(x)
			if strings.HasPrefix(x, "\"") {
				return fmt.Sprintf("%q", x)
			}
			return x
		}
		return fmt.Sprintf("%q", e)
	default:
		return fmt.Sprint(v)
	}
}

func indent(v string, n int) string {
	s := " "
	for i := 0; i < n; i++ {
		s += " "
	}
	return s + v
}

// Clone traverse n and copies the tree to e.
func Clone(n *html.Node, e *Node) {
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		ch := &Node{
			Type:      c.Type,
			DataAtom:  c.DataAtom,
			Data:      c.Data,
			Namespace: c.Namespace,
			Attr:      make([]Attribute, len(c.Attr)),
		}
		for _, v := range c.Attr {
			ch.Attr = append(ch.Attr, Attribute{
				Namespace: v.Namespace,
				Key:       v.Key,
				Val:       v.Val,
			})
		}
		e.Children = append(e.Children, ch)
		Clone(c, ch)
	}
}

// Clear removes nodes injected by the parser.
func Clear(n *Node) *Node {
	if len(n.Children) > 0 && n.Children[0].DataAtom == atom.Html {
		// this is the root node. The html parser injects html,bead,body tags by
		// default.
		//
		// The plan here is to remove the injected  tags
		body := n.Children[0].Children[1]
		if len(body.Children) > 1 {
			// wrap the children in a container
			return &Node{
				Type:     html.ElementNode,
				Data:     ContainerNode,
				Children: body.Children,
			}
		}
		return body.Children[0]
	}
	return n
}

func nonilExpr(x ...ast.Expr) []ast.Expr {
	var ls []ast.Expr
	for _, v := range x {
		if v != nil {
			ls = append(ls, v)
		}
	}
	return ls
}

func formatNodeType(n html.NodeType) string {
	switch n {
	case html.ErrorNode:
		return "ErrorNode"
	case html.TextNode:
		return "TextNode"
	case html.DocumentNode:
		return "DocumentNode"
	case html.ElementNode:
		return "ElementNode"
	case html.CommentNode:
		return "CommentNode"
	case html.DoctypeNode:
		return "DoctypeNode"
	default:
		return "ErrorNode"
	}
}

const fnTpl = `// Code generated by vected DO NOT EDIT.
package {{.ctx.Package}}

import (
	"github.com/gernest/vected/vdom"
	"github.com/gernest/vected/props"
	"github.com/gernest/vected/state"
	"golang.org/x/net/html/atom"
	"golang.org/x/net/html"
)

// Render implements vected.Renderer interface.
func ({{.ctx.Recv}} {{.ctx.StructName}})Render(props props.Props, state state.State)*vdom.Node{
	return {{.node -}}
}
`

var tpl = template.Must(template.New("n").Parse(fnTpl))

type Context struct {
	Package    string
	Recv       string
	StructName string
}

// GenerateRenderMethod using the given context, this returns a new go file with
// the Render method attached to the struct defined in ctx.
func GenerateRenderMethod(n *Node, ctx *Context) ([]byte, error) {
	var buf bytes.Buffer
	nstr := n.Print(0, false)
	buf.Reset()
	err := tpl.Execute(&buf, map[string]interface{}{
		"ctx":  ctx,
		"node": nstr,
	})
	if err != nil {
		return nil, err
	}
	return format.Source(buf.Bytes())
}

// Parse parses src
func Parse(r io.Reader) (*Node, error) {
	doc, err := html.Parse(r)
	if err != nil {
		return nil, err
	}
	o := &Node{
		Data: doc.Data,
	}
	Clone(doc, o)
	return Clear(o), nil
}

// ParseString helper that wraps s to io.Reader.
func ParseString(s string) (*Node, error) {
	return Parse(strings.NewReader(s))
}
