package parser

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"io"
	"strings"
	"text/template"

	"github.com/gernest/vected/vdom"
	"golang.org/x/net/html"
	"golang.org/x/net/html/atom"
)

// Clone traverse n and copies the tree to e.
func Clone(n *html.Node, e *vdom.Node) {
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		ch := &vdom.Node{
			Type:      vdom.NodeType(uint32(c.Type)),
			Data:      c.Data,
			Namespace: c.Namespace,
			Attr:      make([]vdom.Attribute, len(c.Attr)),
		}
		for _, v := range c.Attr {
			ch.Attr = append(ch.Attr, vdom.Attribute{
				Namespace: v.Namespace,
				Key:       v.Key,
				Val:       v.Val,
			})
		}
		e.Children = append(e.Children, ch)
		Clone(c, ch)
	}
}

// Clear removes nodes injected by the parser.
func Clear(n *vdom.Node) *vdom.Node {
	if len(n.Children) > 0 &&
		atom.Lookup([]byte(n.Children[0].Data)) == atom.Html {
		// this is the root node. The html parser injects html,bead,body tags by
		// default.
		//
		// The plan here is to remove the injected  tags
		body := n.Children[0].Children[1]
		if len(body.Children) > 1 {
			// wrap the children in a container
			return &vdom.Node{
				Type:     vdom.ElementNode,
				Data:     vdom.ContainerNode,
				Children: body.Children,
			}
		}
		return body.Children[0]
	}
	return n
}

const fnTpl = `// Code generated by vected DO NOT EDIT.
package {{.pkg}}

import (
	"github.com/gernest/vected/vdom"
	"github.com/gernest/vected/prop"
	"github.com/gernest/vected/state"
	"context"
)

var H =vdom.New
var HA= vdom.Attr
var HAT= vdom.Attrs

{{range .ctx}}
// Render implements vected.Renderer interface.
func ({{.Recv}} {{.StructName}})Render(ctx context.Context, props prop.Props, state state.State)*vdom.Node{
	return {{text .Node -}}
}
{{end}}

`

type Context struct {
	Recv       string
	StructName string
	Node       *vdom.Node
}

// GenerateRenderMethod using the given context, this returns a new go file with
// the Render method attached to the struct defined in ctx.
func GenerateRenderMethod(pkg string, ctx ...Context) ([]byte, error) {
	tpl, err := template.New("n").Funcs(template.FuncMap{
		"text": func(n *vdom.Node) string {
			return printNode(n, 0)
		},
	}).Parse(fnTpl)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	buf.Reset()
	err = tpl.Execute(&buf, map[string]interface{}{
		"pkg": pkg,
		"ctx": ctx,
	})
	if err != nil {
		return nil, err
	}
	// ioutil.WriteFile("test/test.gen.go", buf.Bytes(), 0600)
	return format.Source(buf.Bytes())
}

// Parse parses src
func Parse(r io.Reader) (*vdom.Node, error) {
	doc, err := html.Parse(r)
	if err != nil {
		return nil, err
	}
	o := &vdom.Node{
		Data: doc.Data,
	}
	Clone(doc, o)
	return Clear(o), nil
}

// ParseString helper that wraps s to io.Reader.
func ParseString(s string) (*vdom.Node, error) {
	return Parse(strings.NewReader(s))
}

func parseExpression(x string) (ast.Expr, error) {
	return parser.ParseExpr(x)
}
